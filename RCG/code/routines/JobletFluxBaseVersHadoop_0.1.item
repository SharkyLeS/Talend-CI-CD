package routines;

import java.util.Arrays;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.google.common.base.Joiner;

/*
 * user specification: the function's comment should contain keys as follows: 1. write about the function's comment.but
 * it must be before the "{talendTypes}" key.
 * 
 * 2. {talendTypes} 's value must be talend Type, it is required . its value should be one of: String, char | Character,
 * long | Long, int | Integer, boolean | Boolean, byte | Byte, Date, double | Double, float | Float, Object, short |
 * Short
 * 
 * 3. {Category} define a category for the Function. it is required. its value is user-defined .
 * 
 * 4. {param} 's format is: {param} <type>[(<default value or closed list values>)] <name>[ : <comment>]
 * 
 * <type> 's value should be one of: string, int, list, double, object, boolean, long, char, date. <name>'s value is the
 * Function's parameter name. the {param} is optional. so if you the Function without the parameters. the {param} don't
 * added. you can have many parameters for the Function.
 * 
 * 5. {example} gives a example for the Function. it is optional.
 */
public class JobletFluxBaseVersHadoop {
	
	//static Logger logg = Logger.getLogger(JobletFluxBaseVersHadoop.class);
	
	public static void initLogger() {
		 Logger.getAnonymousLogger().setLevel(Level.WARNING);
	}

    /**
     * helloExample: not return value, only print "hello" + message.
     * 
     * 
     * {talendTypes} String
     * 
     * {Category} User Defined
     * 
     * {param} string("world") input: The string need to be printed.
     * 
     * {example} helloExemple("world") # hello world !.
     */
    public static void helloExample(String message) {
        if (message == null) {
            message = "World"; //$NON-NLS-1$
        }
        System.out.println("Hello " + message + " !"); //$NON-NLS-1$ //$NON-NLS-2$
    }
    
    public static String getQueryConcatFieldsWithPrefixe(String fields,String nullValue, String prefixe) {
    	String[] liste = fields.split(",");
    	String result="";
    	int cpt = 0;
    	int length = liste.length;
    	String field="";
    	for(String base_field:liste) {
    		if(prefixe.equals(""))
    			field=base_field;
    		else
    			field=String.format("%s.%s",prefixe, base_field);
    			
    		
    		if(cpt<length-1)
    			result +=String.format("cast(case when %s is NULL then '%s' else string(%s) end as string),\n",field,nullValue,field);
    		else
    			result +=String.format("cast(case when %s is NULL then '%s' else string(%s) end as string)\n",field,nullValue,field);
    		cpt++;
    	}
    	return result.toUpperCase();
    	
    }
    
    public static String getQueryConcatFields(String fields,String nullValue) {
    	return JobletFluxBaseVersHadoop.getQueryConcatFieldsWithPrefixe(fields, nullValue, "");
    	
    }
    
    /*public static String getQueryConcatMaxFields(String fields) {
    	String[] liste = fields.split(",");
    	String result="";
    	int cpt = 0;
    	int length = liste.length;
    	for(String field:liste) {
    		if(cpt<length-1)
    			result +=String.format("cast(max(%s) as string),",field);
    		else
    			result +=String.format("cast(max(%s) as string)",field);
    		cpt++;
    	}
    	return result.toUpperCase();
    	
    }*/
    
    public static String getQueryConcatMaxFields(String fields, String last_value) {
    	String[] liste = fields.split(",");
    	String[] values = last_value.split(",");
    	String result="";
    	int cpt = 0;
    	int length = liste.length;
    	for(String field:liste) {
    		String value = values[cpt];
    		if(cpt<length-1)
    			result +=String.format("CASE WHEN max(%s) IS NULL THEN '%s' else cast(max(%s) as string) end,",field,value,field);
    		else
    			result +=String.format("CASE WHEN max(%s) IS NULL THEN '%s' else cast(max(%s) as string) end",field,value,field);
    		cpt++;
    	}
    	return result.toUpperCase();
    	
    }
    
    
    public static String updateFields(String fields,String dwhFileds,String tab){
    	String result="";
    	String[] listTmp = fields.split(",");
    	String[] listDWH = dwhFileds.split(",");
    	int compteur=0;
    	int listLength=listTmp.length;
    	for(String field:listTmp) {
    		if(compteur<listLength-1)
    			result +=String.format("%s=%s.%s,",listDWH[compteur],tab,field);
    		else
    			result +=String.format("%s=%s.%s",listDWH[compteur],tab,field);
    		compteur++;
    	}
    	return result.toUpperCase();
    }
    
    public static String concatStatus(String list){
    	String[] listTmp = list.split(",");
    	String concat="";
    	int compteur=0;
    	int listLength=listTmp.length;
    	for(String field:listTmp) {
    		if (listTmp[compteur] != "NULL" && listTmp[compteur] != "null" && listTmp[compteur] != null && !listTmp[compteur].isEmpty()){
    			if(compteur<listLength-1)
        			concat +=String.format("%s|",listTmp[compteur]);
        		else
        			concat +=String.format("%s",listTmp[compteur]);
    		}    		
    		compteur++;
    	}
    	return concat;
    }
    
    public static String whereFields(String fields,String dwhFileds,String tab,String tab1){
    	String result="";
    	String[] listTmp = fields.split(",");
    	String[] listDWH = dwhFileds.split(",");
    	int compteur=0;
    	int listLength=listTmp.length;
    	if (tab1.isEmpty()){
    	for(String field:listTmp) {
    		if(compteur<listLength-1)
    			result +=String.format("%s=%s.%s and ",listDWH[compteur],tab,field);
    		else
    			result +=String.format("%s=%s.%s",listDWH[compteur],tab,field);
    		compteur++;
    	}
    	}
    	else
    	{
        	for(String field:listTmp) {
        		if(compteur<listLength-1)
        			result +=String.format("%s.%s=%s.%s and ",tab1,listDWH[compteur],tab,field);
        		else
        			result +=String.format("%s.%s=%s.%s",tab1,listDWH[compteur],tab,field);
        		compteur++;
        	}	
    	}
    	return result.toUpperCase();
    }
    
    //pas encore utilisÃ©
    public static int getIndex(String values, String elem){
    	String []tab = values.split(",");
    	int index= 0;
    	for(String value:tab) {
    		if (value.toLowerCase().equals(elem.toLowerCase()))
    			return index;
    		index ++;
    	}
    	return -1;
    	
    	
    }
    
    public static String addPrefixe(String fields, String separator, String prefixe){
    	String result ="";
    	String [] tab = fields.split(separator);
    	for(String str:tab)
    	{
    		result += prefixe + "." + str + ",";
    	}
    	return result.substring(0,result.length()-1);
    }
    
    public static String subsLists(String globalList,String keylList){
    	String[] listGlob = globalList.toUpperCase().split(",");
    	String[] listKey = keylList.toUpperCase().split(",");
    	String[] columnsOutOfScheama = new String[]{"D_MAJ","D_CRE"};
    	TreeSet<String> setcolumnsOutOfScheama = new TreeSet(Arrays.asList(columnsOutOfScheama));
    	TreeSet<String> glob = new TreeSet(Arrays.asList(listGlob));
    	TreeSet<String> key = new TreeSet(Arrays.asList(listKey));
    	glob.removeAll(setcolumnsOutOfScheama);
    	glob.removeAll(key);
    	String result = Joiner.on(",").join(glob);
    	return result;
    }
}
